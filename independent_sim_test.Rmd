---
output:
  pdf_document:
    fig_caption: no
    number_sections: no
    toc: yes
    toc_depth: 2
    # github_document:
    # html_preview: yes
    # toc: yes
    # toc_depth: 2
editor_options: 
  chunk_output_type: inline
---

# Dependencies
```{r setup, message=FALSE}
library(ggplot2)
library(tibble)
library(cowplot)
library(beepr)
library(Rfast)
library(changepoint)
library(mcp)
library(rjags)
library(mutoss)
source("./code/functions.R")
source("./code/theme_gar.txt")
# Edit `one_over_f` function from `primer` package to control variance (Stevens, 2009). 
# Original function is available on [GitHub](https://github.com/HankStevens/primer).
# Copyright Hank Stevens.
source("./code/one_over_f.R")
# Load template: true onset = 160 ms, F=81, max at F=126
source("./code/erp_template.R")
# R version of Matlab code from Yeung et al. 2004
source("./code/eeg_noise.R")
# Lodaing the code that gives median instead of mean values in mcp summary table
source("./code/mcp_median_function.R")
# to use with eeg_noise function
meanpower <- unlist(read.table("./code/meanpower.txt"))
```

Tried to run simulation on my desktop. the whole thing would get stuck after 120 iterations. There would not be any errors and the loop would keep running, but nothing would be printed in the console. Then I removed bky method from sampling because I've had some issues with setting that up, however, then the simulation would crash after some number of iterations (it seemed like over 120 though). To diagnose what the problem is I will separate the simulation into 4 separate parts and run them all independently which should help determine which part of the code is not working. The simulation will be split into 4 parts: cp + cs + fdr (because they come from the original simulation so they should all work without issue), bky (there are some issues with the implementation of this method), mcp mean and median (computationally intensive method - maybe this is whats causing the crashing), pelt. 

### cp cs fdr
```{r warning=FALSE, include=FALSE}

ptm <- proc.time() # Timing code chunk execution

set.seed(666)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10000 # simulation iterations
nboot <- 2000 # number of permutation samples
simres.cp  <- vector(mode = "numeric", length = nsim) * NA
simres.cs  <- vector(mode = "numeric", length = nsim) * NA
simres.fdr <- vector(mode = "numeric", length = nsim) * NA

Nt <- 50 # number of trials
gsp <- 1 # gamma spectral power
outvar <- 1 # noise variance
cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

for(S in 1:nsim){
  
  for(T in 1:Nt){
    cond2[T,] <- temp2 + one_over_f(gamma = gsp, Nf, outvar = outvar)
    cond1[T,] <- temp1 + one_over_f(gamma = gsp, Nf, outvar = outvar)  
  }
  # t-tests
  ori.t2 <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
  }
  
  # fit change point model
  res.cp <- cpt.meanvar(ori.t2, method = "BinSeg", Q=2)
  simres.cp[S] <- Xf[res.cp@cpts[1]]
  
  # Make permutation table of t values 
  perm.t2 <- permtdist(cond1, cond2, Nt, Nf, nboot = nboot)^2
  perm.th <- apply(perm.t2, 2, quantile, probs = 1-aath)
  
  perm.pvals <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    perm.pvals[F] <- (sum(perm.t2[,F] >= ori.t2[F]) + 1) / (nboot + 1)
  }
  
  # FDR
  fdr.pvals <- p.adjust(perm.pvals, method = "fdr")
  simres.fdr[S] <- find_onset(fdr.pvals <= aath, Xf)
  
  # cluster-sum statistics -----
  cmap <- cluster.make(perm.pvals <= aath)
  perm.max.sums <- vector(mode = "numeric", length = nboot)
  for(B in 1:nboot){
    # threshold permutation t2 values and form clusters
    perm.cmap <- cluster.make(perm.t2[B,] <= perm.th)  
    perm.max.sums[B] <- max(cluster.sum(values = perm.t2[B,], cmap = perm.cmap))
  }
  # cluster sum threshold
  cs.th <- quantile(perm.max.sums, probs = 1-aath)
  # cluster test
  cs.test <- cluster.test(values = ori.t2, cmap = cmap, cs.th)
  simres.cs[S] <- find_onset(cs.test, Xf)
}

save(simres.cs, simres.cp, simres.fdr,
     file = "./data/onsetsim_all_methods_sim_cs_cp_fdr.RData")

proc.time()-ptm
```

### bky - doesnt work

```{r}
ptm <- proc.time() # Timing code chunk execution

library(mutoss)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10000 # simulation iterations
nboot <- 2000 # number of permutation samples
inc.step <- 500 # console notification every inc.step iterations
simres.bky <- vector(mode = "numeric", length = nsim) * NA
Nt <- 50 # number of trials
gsp <- 1 # gamma spectral power
outvar <- 1 # noise variance
cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

for(S in 1:nsim){

  for(T in 1:Nt){
    cond2[T,] <- temp2 + one_over_f(gamma = gsp, Nf, outvar = outvar)
    cond1[T,] <- temp1 + one_over_f(gamma = gsp, Nf, outvar = outvar)
  }
  # t-tests
  ori.t2 <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
  }

  # Make permutation table of t values
  perm.t2 <- permtdist(cond1, cond2, Nt, Nf, nboot = nboot)^2
  perm.th <- apply(perm.t2, 2, quantile, probs = 1-aath)

  perm.pvals <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    perm.pvals[F] <- (sum(perm.t2[,F] >= ori.t2[F]) + 1) / (nboot + 1)
  }

  # BKY
  bky.res <- two.stage(pValues = perm.pvals, alpha = aath)
  bky.pvals <- bky.res$adjPValues
  simres.bky[S] <- find_onset(bky.pvals <= aath, Xf)
}

df <- tibble(onsets = simres.bky,
             method = factor(rep("BKY", length(simres.bky)))
)

# save(simres.bky,
  #    file = "./data/onsetsim_all_methods_sim_bky.RData")

proc.time()-ptm
```

```{r}
set.seed(666)
aath <- 0.05
nsim <- 10
nboot <- 2000
inc.step <- 500
simres_list <- vector("list", nsim)  # Create a list to hold the results
Nt <- 50
gsp <- 1
outvar <- 1

for(S in 1:nsim){
  for(T in 1:Nt){
    cond2[T,] <- temp2 + one_over_f(gamma = gsp, Nf, outvar = outvar)
    cond1[T,] <- temp1 + one_over_f(gamma = gsp, Nf, outvar = outvar)
  }
  # t-tests
  ori.t2 <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
  }

  perm.t2 <- permtdist(cond1, cond2, Nt, Nf, nboot = nboot)^2
  perm.th <- apply(perm.t2, 2, quantile, probs = 1-aath)
  
  perm.pvals <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    perm.pvals[F] <- (sum(perm.t2[,F] >= ori.t2[F]) + 1) / (nboot + 1)
  }

  bky.res <- two.stage(perm.pvals, alpha = aath)
  bky.pvals <- bky.res$adjPValues
  simres_list[[S]] <- find_onset(bky.pvals <= aath, Xf)
}

# Access the results
simres_list[[1]]  # Access the first simulation result

```



### mcp mean and median

```{r warning=FALSE, include=FALSE}
ptm <- proc.time() # Timing code chunk execution
options(mc.cores = 3)
set.seed(666)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10000 # simulation iterations
nboot <- 2000 # number of permutation samples
inc.step <- 500 # console notification every inc.step iterations
simres.mcp.median <- vector(mode = "numeric", length = nsim) * NA
simres.mcp.mean <- vector(mode = "numeric", length = nsim) * NA

Nt <- 50 # number of trials
gsp <- 1 # gamma spectral power
outvar <- 1 # noise variance
cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

for(S in 1:nsim){
  
  for(T in 1:Nt){
    cond2[T,] <- temp2 + one_over_f(gamma = gsp, Nf, outvar = outvar)
    cond1[T,] <- temp1 + one_over_f(gamma = gsp, Nf, outvar = outvar)  
  }
  # t-tests
  ori.t2 <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
  }
  
  # fit mcp model
  df <- tibble(x = Xf, y = ori.t2)
  model <- list(
    y ~ 1 + sigma(1),
      ~ 0 + x + sigma(1)
  )
  
  prior <- list(
    cp_1 = "dunif(100, 200)" # Change point expected between 100 and 200 ms
  )
  
  fit <- mcp(model, data = df, prior = prior, cores = 3, chains = 3)
  
  summary.fit.median <- summary.mcpfit.median(fit)
  simres.mcp.median[S] <- round(summary.fit.median[1,2],0)
  
  # Fitting the same model but for the mean function to compare to median
  summary.fit.mean <- mcp:::summary.mcpfit(fit)
  simres.mcp.mean[S] <- round(summary.fit.mean[1,2],0)
}

save(simres.mcp.median, simres.mcp.mean,
     file = "./data/onsetsim_all_methods_sim_mcp.RData")

proc.time()-ptm
```


### pelt

```{r}
ptm <- proc.time() # Timing code chunk execution

set.seed(666)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10000 # simulation iterations
nboot <- 2000 # number of permutation samples
inc.step <- 500 # console notification every inc.step iterations
simres.pelt <- vector(mode = "numeric", length = nsim) * NA

Nt <- 50 # number of trials
gsp <- 1 # gamma spectral power
outvar <- 1 # noise variance
cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

for(S in 1:nsim){
  
  sim.counter(S, nsim, inc = inc.step)
  
  for(T in 1:Nt){
    cond2[T,] <- temp2 + one_over_f(gamma = gsp, Nf, outvar = outvar)
    cond1[T,] <- temp1 + one_over_f(gamma = gsp, Nf, outvar = outvar)  
  }
  # t-tests
  ori.t2 <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
  }
  
  # Fit PELT 
  res.pelt <- cpt.meanvar(ori.t2, method = "PELT", penalty = "Manual", pen.value = 15*log(length(ori.t2)))
  simres.pelt[S] <- Xf[res.pelt@cpts[1]]
}

save(simres.pelt,
     file = "./data/onsetsim_all_methods_sim_pelt.RData")

proc.time()-ptm
```

