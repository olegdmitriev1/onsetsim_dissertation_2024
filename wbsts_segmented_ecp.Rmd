---
output:
  pdf_document:
    fig_caption: no
    number_sections: no
    toc: yes
    toc_depth: 2
    # github_document:
    # html_preview: yes
    # toc: yes
    # toc_depth: 2
editor_options: 
  chunk_output_type: inline
---

# Dependencies
```{r setup, message=FALSE}
library(ggplot2)
library(tibble)
library(cowplot)
library(beepr)
library(Rfast)
library(changepoint)
library(mcp)
library(rjags)
library(mutoss)
source("./code/functions.R")
source("./code/theme_gar.txt")
# Edit `one_over_f` function from `primer` package to control variance (Stevens, 2009). 
# Original function is available on [GitHub](https://github.com/HankStevens/primer).
# Copyright Hank Stevens.
source("./code/one_over_f.R")
# Load template: true onset = 160 ms, F=81, max at F=126
source("./code/erp_template.R")
# R version of Matlab code from Yeung et al. 2004
source("./code/eeg_noise.R")
# Lodaing the code that gives median instead of mean values in mcp summary table
source("./code/mcp_median_function.R")
# to use with eeg_noise function
meanpower <- unlist(read.table("./code/meanpower.txt"))
```

### ecp - e.cp3o_delta
```{r warning=FALSE}
# Reference: ecp: An R Package for Nonparametric Multiple Change Point Analysis of Multivariate Data - James and Matteson, 2014
# Up to date manual: https://cran.r-project.org/web/packages/ecp/ecp.pdf
library(ecp)
set.seed(666)
srate <- 500 # Sampling rate in Hz
Nt <- 50 # number of trials
outvar <- 1 # noise variance
cond1 <- matrix(0, nrow = Nt, ncol = Nf) 
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

for(T in 1:Nt){
  cond2[T,] <- temp2 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
  cond1[T,] <- temp1 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
}

ori.t2 <- vector(mode = "numeric", length = Nf)

for(F in 1:Nf){
  ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
}


ori.t2 <- matrix(ori.t2, ncol = 1)

# Run e.cp3o_delta for detecting a single change point
result_cp3o_delta <- e.cp3o_delta(Z = ori.t2, K = 7, alpha = 1)

# Print the estimated change point location
res <- Xf[result_cp3o_delta$estimates]


df <- tibble(x = Xf,
             y = ori.t2)

p.cp <- ggplot(df, aes(x, y)) + theme_gar + 
  geom_line(linewidth = 1) +
  geom_vline(xintercept = true_onset) +
  geom_vline(xintercept = Xf[result_cp3o_delta$estimates], linetype = "dotted") +
  labs(x = "Time in ms", y = bquote(t^2)) +
  ggtitle(paste("Change point onset =", Xf[result_cp3o_delta$estimates], "ms"))
p.cp







# cps = list of change point locations identified by the algorithm 
# Xf  = a vector of time points 

# Function to extract the earliest change point
get_earliest_cp <- function(cps, Xf) {
  if (length(cps) > 0) {
    # Find the earliest point
    earliest_index <- min(cps)
    # Convert to time course using the time vector
    earliest_time <- Xf[earliest_index]
    return(earliest_time)
  } else {
    return(NA)  # Return NA if no change points were found
  }
}




# Run the change point detection
result_cp3o_delta <- e.cp3o_delta(Z = ori.t2, K = 7, alpha = 1)

# Extract the earliest change point's time
earliest_cp_time <- get_earliest_cp(result_cp3o_delta$estimates, Xf)

df <- tibble(x = Xf, 
             y = as.vector(ori.t2))


p.cp <- ggplot(df, aes(x, y)) + theme_gar + 
  geom_line(linewidth = 1) +
  geom_vline(xintercept = true_onset) +
  geom_vline(xintercept = earliest_cp_time, linetype = "dotted") +
  labs(x = "Time in ms", y = bquote(t^2)) +
  ggtitle(paste("Change point onset =", earliest_cp_time, "ms"))
p.cp
```

### e.cp3o_delta simulation for onset distribution 

Above graph shows that the method is capable of identifying change point correctly. Now the goal will be to put it into a simulation to check that it works when EEG time courses change. 

```{r}
ptm <- proc.time() # Timing code chunk execution

aath <- 0.05 # arbitrary alpha threshold
nsim <- 1000 # simulation iterations
nboot <- 2000 # number of permutation samples
simres.ecp <- vector(mode = "numeric", length = nsim) * NA

Nt <- 50 # number of trials
gsp <- 1 # gamma spectral power
outvar <- 1 # noise variance
cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

for(S in 1:nsim){
  
  for(T in 1:Nt){
    cond2[T,] <- temp2 + one_over_f(gamma = gsp, Nf, outvar = outvar)
    cond1[T,] <- temp1 + one_over_f(gamma = gsp, Nf, outvar = outvar)  
  }
  # t-tests
  ori.t2 <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
  }
  
  ori.t2 <- matrix(ori.t2, ncol = 1)
  
  # fit ecp cp3o_delta model
  result_cp3o_delta <- e.cp3o_delta(Z = ori.t2, K = 7, alpha = 1)
  simres.ecp[S] <- get_earliest_cp(result_cp3o_delta$estimates, Xf)
  
}

save(simres.ecp, 
     file = "./data/onsetsim_ecp_sim.RData")

proc.time()-ptm
```

```{r, warning=FALSE, fig.height=8, fig.width=8}
load("./data/onsetsim_ecp_sim.RData")

# Colour palette from http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/
categ.palette <- c("#000000", "#E69F00", "#009E73", "#0072B2", "#D55E00", "#CC79A7")

df <- tibble(onsets = simres.ecp,
             method = factor(rep("ecp", length(simres.ecp)))
)

ggplot(data = df, aes(x = onsets, colour = method)) + theme_gar +
  # stat_density(geom = "line") +
  geom_freqpoly(fill = "white", na.rm = TRUE, breaks = Xf) +
  geom_vline(xintercept = true_onset, linetype = "dashed") +
  # geom_vline(xintercept = median(simres.cp, na.rm = TRUE))
  scale_colour_manual(values = categ.palette) +
  theme(legend.position = c(.8, .8)) +
  labs(x = "Onsets in ms", y = "Count")
```

### alpha = 2 test

```{r}
ptm <- proc.time() # Timing code chunk execution
set.seed(666)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10 # simulation iterations
nboot <- 2000 # number of permutation samples
simres.ecp <- vector(mode = "numeric", length = nsim) * NA

Nt <- 50 # number of trials
gsp <- 1 # gamma spectral power
outvar <- 1 # noise variance
cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

for(S in 1:nsim){
  
  for(T in 1:Nt){
    cond2[T,] <- temp2 + one_over_f(gamma = gsp, Nf, outvar = outvar)
    cond1[T,] <- temp1 + one_over_f(gamma = gsp, Nf, outvar = outvar)  
  }
  # t-tests
  ori.t2 <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
  }
  
  ori.t2 <- matrix(ori.t2, ncol = 1)
  
  # fit ecp cp3o_delta model
  result_cp3o_delta <- e.cp3o_delta(Z = ori.t2, K = 8, alpha = 1)
  simres.ecp[S] <- get_earliest_cp(result_cp3o_delta$estimates, Xf)
  
}

# save(simres.ecp, 
  #    file = "./data/onsetsim_ecp_sim_alpha2_DELETE.RData")

proc.time()-ptm
```

```{r, warning=FALSE, fig.height=6, fig.width=8}
load("./data/onsetsim_ecp_sim_alpha2_DELETE.RData")

# Colour palette from http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/
categ.palette <- c("#000000", "#E69F00", "#009E73", "#0072B2", "#D55E00", "#CC79A7")

df <- tibble(onsets = simres.ecp,
             method = factor(rep("ecp", length(simres.ecp)))
)

ggplot(data = df, aes(x = onsets, colour = method)) + theme_gar +
  # stat_density(geom = "line") +
  geom_freqpoly(fill = "white", na.rm = TRUE, breaks = Xf) +
  geom_vline(xintercept = true_onset, linetype = "dashed") +
  # geom_vline(xintercept = median(simres.cp, na.rm = TRUE))
  scale_colour_manual(values = categ.palette) +
  theme(legend.position = c(.8, .8)) +
  labs(x = "Onsets in ms", y = "Count")
```

### no delta k1 a1
```{r}

# Function to extract the earliest change point
get_earliest_cp <- function(cps, Xf) {
  if (length(cps) > 0) {
    # Find the earliest point
    earliest_index <- min(cps)
    # Convert to time course using the time vector
    earliest_time <- Xf[earliest_index]
    return(earliest_time)
  } else {
    return(NA)  # Return NA if no change points were found
  }
}


library(ecp)
ptm <- proc.time() # Timing code chunk execution
set.seed(666)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10000 # simulation iterations
nboot <- 2000 # number of permutation samples
simres.ecp <- vector(mode = "numeric", length = nsim) * NA

Nt <- 50 # number of trials
gsp <- 1 # gamma spectral power
outvar <- 1 # noise variance
cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

for(S in 1:nsim){
  
  for(T in 1:Nt){
    cond2[T,] <- temp2 + one_over_f(gamma = gsp, Nf, outvar = outvar)
    cond1[T,] <- temp1 + one_over_f(gamma = gsp, Nf, outvar = outvar)  
  }
  # t-tests
  ori.t2 <- vector(mode = "numeric", length = Nf)
  for(F in 1:Nf){
    ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
  }
  
  ori.t2 <- matrix(ori.t2, ncol = 1)
  
  # fit ecp cp3o_delta model
  result_cp3o_delta <- e.cp3o_delta(Z = ori.t2, K=7, alpha=1)
  simres.ecp[S] <- get_earliest_cp(result_cp3o_delta$estimates, Xf)
  
}

save(simres.ecp, 
     file = "./data/onsetsim_ecp_sim_nodelta_k7_a1_DELETE.RData")

proc.time()-ptm
```

```{r, warning=FALSE, fig.height=6, fig.width=8}
load("./data/onsetsim_ecp_sim_nodelta_k7_a1_DELETE.RData")

# Colour palette from http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/
categ.palette <- c("#000000", "#E69F00", "#009E73", "#0072B2", "#D55E00", "#CC79A7")

df <- tibble(onsets = simres.ecp,
             method = factor(rep("ecp", length(simres.ecp)))
)

ggplot(data = df, aes(x = onsets, colour = method)) + theme_gar +
  # stat_density(geom = "line") +
  geom_freqpoly(fill = "white", na.rm = TRUE, breaks = Xf) +
  geom_vline(xintercept = true_onset, linetype = "dashed") +
  # geom_vline(xintercept = median(simres.cp, na.rm = TRUE))
  scale_colour_manual(values = categ.palette) +
  theme(legend.position = c(.8, .8)) +
  labs(x = "Onsets in ms", y = "Count") + 
  ylim(0,650)
```


### e.divisive method check - isnt good

```{r}
set.seed(666)
srate <- 500 # Sampling rate in Hz
Nt <- 50 # number of trials
outvar <- 1 # noise variance
cond1 <- matrix(0, nrow = Nt, ncol = Nf) 
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

for(T in 1:Nt){
  cond2[T,] <- temp2 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
  cond1[T,] <- temp1 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
}

ori.t2 <- vector(mode = "numeric", length = Nf)

for(F in 1:Nf){
  ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
}

ori.t2 <- matrix(ori.t2, ncol = 1)

res.e.divisive <- e.divisive(ori.t2, sig.lvl = 0.05, alpha = 1)

# Print the estimated change point location
res <- Xf[res.e.divisive$estimates]


df <- tibble(x = Xf,
             y = ori.t2)

p.cp <- ggplot(df, aes(x, y)) + theme_gar + 
  geom_line(linewidth = 1) +
  geom_vline(xintercept = true_onset) +
  geom_vline(xintercept = Xf[res.e.divisive$estimates], linetype = "dotted") +
  labs(x = "Time in ms", y = bquote(t^2)) +
  ggtitle(paste("Change point onset =", Xf[res.e.divisive$estimates], "ms"))
p.cp
```

