---
output:
  pdf_document:
    fig_caption: no
    number_sections: no
    toc: yes
    toc_depth: 2
    # github_document:
    # html_preview: yes
    # toc: yes
    # toc_depth: 2
editor_options: 
  chunk_output_type: inline
---

# Dependencies
```{r setup, message=FALSE}
library(ggplot2)
library(tibble)
library(cowplot)
library(beepr)
library(Rfast)
library(changepoint)
library(mcp)
library(rjags)
library(mutoss)
library(ecp)
source("./code/functions.R")
source("./code/theme_gar.txt")
# Edit `one_over_f` function from `primer` package to control variance (Stevens, 2009). 
# Original function is available on [GitHub](https://github.com/HankStevens/primer).
# Copyright Hank Stevens.
source("./code/one_over_f.R")
# Load template: true onset = 160 ms, F=81, max at F=126
source("./code/erp_template.R")
# R version of Matlab code from Yeung et al. 2004
source("./code/eeg_noise.R")
# Lodaing the code that gives median instead of mean values in mcp summary table
source("./code/mcp_median_function.R")
# to use with eeg_noise function
meanpower <- unlist(read.table("./code/meanpower.txt"))
```

```{r, eval=FALSE, warning=FALSE, include=FALSE}

library(doParallel)
library(foreach)

#######################################
# Parallel processing setup
cores <- detectCores()
cl <- makeCluster(cores - 4)
registerDoParallel(cl)

big_list <- list()

big_list <- foreach(i = 1:1000) %dopar% {
  big_list[i] <- i^2
}

stopCluster(cl)
#######################################


ptm <- proc.time()
set.seed(666)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10 # simulation iterations
nboot <- 2000 # number of permutation samples
srate <- 500 # sampling rate in Hz
ronset <- seq(150, 170, 2) # random onset for each participant

# Priors for Bayesian model
prior <- list(
  cp_1 = "dunif(100, 250)" # Change point expected between 100 and 250 ms
)

# Setting up Bayesian model
model <- list(
  y ~ 1 + sigma(1),
    ~ 0 + x + sigma(1)
)

Nt <- 50 # number of trials
Np <- 20 # number of participants
outvar <- 1 # noise variance

cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

simres.cp <- matrix(NA, nrow = Np, ncol = nsim)
simres.fdr <- matrix(NA, nrow = Np, ncol = nsim)
simres.cs <- matrix(NA, nrow = Np, ncol = nsim)
simres.pelt <- matrix(NA, nrow = Np, ncol = nsim)
simres.ecp <- matrix(NA, nrow = Np, ncol = nsim)
simres.mcp <- matrix(NA, nrow = Np, ncol = nsim)


for (S in 1:nsim) {
  
  for(P in 1:Np){ # participants
    
    ponset <- sample(ronset, 1) # get random onset
    st <- which(Xf==ponset)
    temp2 <- c(rep(0, st-2), erp, rep(0, Nf-st-length(erp)+2))

    for(T in 1:Nt){
      cond2[T,] <- temp2 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
      cond1[T,] <- temp1 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
    }
    
    # t-tests
    ori.t2 <- vector(mode = "numeric", length = Nf)
    for(F in 1:Nf){
      ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
    }
    
    ###############################################
    
    # Fit BinSeg model
    res <- cpt.meanvar(ori.t2, method = "BinSeg", Q=2)
    simres.cp[P,S] <- Xf[res@cpts[1]]
    
    ###############################################
    
    # Fit PELT with a penalty multiplier of 30
    res.pelt <- cpt.meanvar(ori.t2, method = "PELT", penalty = "Manual", pen.value = 30*log(length(ori.t2)))
    simres.pelt[P,S] <- Xf[res.pelt@cpts[1]]
    
    ###############################################
    
    # Fit mcp model
    df <- tibble(x = Xf, y = ori.t2)

    fit <- mcp(model, prior = prior, data = df)

    summary.fit.median <- summary.mcpfit.median(fit)
    simres.mcp[P,S] <- round(summary.fit.median[1,2],0)
    
    ###############################################
    
    # Make permutation table of t values 
    perm.t2 <- permtdist(cond1, cond2, Nt, Nf, nboot = nboot)^2
    perm.th <- apply(perm.t2, 2, quantile, probs = 1-aath)
    
    # FDR -----
    perm.pvals <- vector(mode = "numeric", length = Nf)
    for(F in 1:Nf){
      perm.pvals[F] <- (sum(perm.t2[,F] >= ori.t2[F]) + 1) / (nboot + 1)
    }
    fdr.pvals <- p.adjust(perm.pvals, method = "fdr")
    simres.fdr[P,S] <- Xf[which(fdr.pvals <= aath)[1]]
    
    ###############################################
    
    # cluster-sum statistics -----
    cmap <- cluster.make(perm.pvals <= aath)
    perm.max.sums <- vector(mode = "numeric", length = nboot)
    for(B in 1:nboot){
      # threshold permutation t2 values and form clusters
      perm.cmap <- cluster.make(perm.t2[B,] <= perm.th)  
      perm.max.sums[B] <- max(cluster.sum(values = perm.t2[B,], cmap = perm.cmap))
    }
    # cluster sum threshold
    cs.th <- quantile(perm.max.sums, probs = 1-aath)
    # cluster test
    cs.test <- cluster.test(values = ori.t2, cmap = cmap, cs.th)
    simres.cs[P,S] <- Xf[cs.test][1]
    
    ##############################################
    
    # Fit non-parametric e.cp3o_delta from ecp package
    ori.t2 <- matrix(ori.t2, ncol = 1) # ecp only accepts matrices 
    
    # Fit ecp cp3o_delta model
    result_cp3o_delta <- e.cp3o_delta(Z = ori.t2, K = 8, alpha = 1)
    simres.ecp[P,S] <- get_earliest_cp(result_cp3o_delta$estimates, Xf)
  }
}

save(simres.cs, simres.fdr, simres.cp, simres.pelt, simres.mcp, simres.mcp.mean, simres.ecp,
     file = "./data/main_sim_n50_eeg_group20.RData")
proc.time()-ptm
```


Chunk below doesnt work
```{r}

# Detect number of cores and initialize cluster
cores <- detectCores()
cl <- makeCluster(cores - 2)  # Reserve a couple of cores for other system tasks
registerDoParallel(cl)

ptm <- proc.time()
set.seed(666)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10 # simulation iterations
nboot <- 2000 # number of permutation samples
srate <- 500 # sampling rate in Hz
ronset <- seq(150, 170, 2) # random onset for each participant

# Priors for Bayesian model
prior <- list(
  cp_1 = "dunif(100, 250)" # Change point expected between 100 and 250 ms
)

# Setting up Bayesian model
model <- list(
  y ~ 1 + sigma(1),
    ~ 0 + x + sigma(1)
)

Nt <- 50 # number of trials
Np <- 20 # number of participants
outvar <- 1 # noise variance

cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

combineResults <- function(old, new) {
  mapply(c, old, new, SIMPLIFY = FALSE)
}

# Run simulations in parallel and collect results
results <- foreach(S = 1:nsim, .combine = 'combineResults', .init = list()) %dopar% {
  # Initialize matrices to store results for each participant in the current simulation
  simres_cp <- matrix(NA, nrow = Np, ncol = 1)
  simres_fdr <- matrix(NA, nrow = Np, ncol = 1)
  simres_cs <- matrix(NA, nrow = Np, ncol = 1)
  simres_pelt <- matrix(NA, nrow = Np, ncol = 1)
  simres_ecp <- matrix(NA, nrow = Np, ncol = 1)
  simres_mcp <- matrix(NA, nrow = Np, ncol = 1)
  
library(tibble)
library(Rfast)
library(changepoint)
library(mcp)
library(rjags)
library(mutoss)
library(ecp)
source("./code/functions.R")
source("./code/one_over_f.R")
# Load template: true onset = 160 ms, F=81, max at F=126
source("./code/erp_template.R")
# R version of Matlab code from Yeung et al. 2004
source("./code/eeg_noise.R")
# Lodaing the code that gives median instead of mean values in mcp summary table
source("./code/mcp_median_function.R")
# to use with eeg_noise function
meanpower <- unlist(read.table("./code/meanpower.txt"))

  for(P in 1:Np){ # participants
    
    ponset <- sample(ronset, 1) # get random onset
    st <- which(Xf==ponset)
    temp2 <- c(rep(0, st-2), erp, rep(0, Nf-st-length(erp)+2))

    for(T in 1:Nt){
      cond2[T,] <- temp2 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
      cond1[T,] <- temp1 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
    }
    
    # t-tests
    ori.t2 <- vector(mode = "numeric", length = Nf)
    for(F in 1:Nf){
      ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
    }
    
    ###############################################
    
    # Fit BinSeg model
    res <- cpt.meanvar(ori.t2, method = "BinSeg", Q=2)
    simres.cp[P,1] <- Xf[res@cpts[1]]
    
    ###############################################
    
    # Fit PELT with a penalty multiplier of 30
    res.pelt <- cpt.meanvar(ori.t2, method = "PELT", penalty = "Manual", pen.value = 30*log(length(ori.t2)))
    simres.pelt[P,1] <- Xf[res.pelt@cpts[1]]
    
    ###############################################
    
    # Fit mcp model
    df <- tibble(x = Xf, y = ori.t2)

    fit <- mcp(model, prior = prior, data = df)

    summary.fit.median <- summary.mcpfit.median(fit)
    simres.mcp[P,1] <- round(summary.fit.median[1,2],0)
    
    ###############################################
    
    # Make permutation table of t values 
    perm.t2 <- permtdist(cond1, cond2, Nt, Nf, nboot = nboot)^2
    perm.th <- apply(perm.t2, 2, quantile, probs = 1-aath)
    
    # FDR -----
    perm.pvals <- vector(mode = "numeric", length = Nf)
    for(F in 1:Nf){
      perm.pvals[F] <- (sum(perm.t2[,F] >= ori.t2[F]) + 1) / (nboot + 1)
    }
    fdr.pvals <- p.adjust(perm.pvals, method = "fdr")
    simres.fdr[P,1] <- Xf[which(fdr.pvals <= aath)[1]]
    
    ###############################################
    
    # cluster-sum statistics -----
    cmap <- cluster.make(perm.pvals <= aath)
    perm.max.sums <- vector(mode = "numeric", length = nboot)
    for(B in 1:nboot){
      # threshold permutation t2 values and form clusters
      perm.cmap <- cluster.make(perm.t2[B,] <= perm.th)  
      perm.max.sums[B] <- max(cluster.sum(values = perm.t2[B,], cmap = perm.cmap))
    }
    # cluster sum threshold
    cs.th <- quantile(perm.max.sums, probs = 1-aath)
    # cluster test
    cs.test <- cluster.test(values = ori.t2, cmap = cmap, cs.th)
    simres.cs[P,1] <- Xf[cs.test][1]
    
    ##############################################
    
    # Fit non-parametric e.cp3o_delta from ecp package
    ori.t2 <- matrix(ori.t2, ncol = 1) # ecp only accepts matrices 
    
    # Fit ecp cp3o_delta model
    result_cp3o_delta <- e.cp3o_delta(Z = ori.t2, K = 8, alpha = 1)
    simres.ecp[P,1] <- get_earliest_cp(result_cp3o_delta$estimates, Xf)
  }

  # Combine all participant results for this simulation
  list(cp = simres_cp, fdr = simres_fdr, cs = simres_cs, pelt = simres_pelt, mcp = simres_mcp, ecp = simres_ecp)
}

save(results,
     file = "./data/main_sim_n50_eeg_group20.RData")

# Stop the parallel cluster
stopCluster(cl)

proc.time()-ptm
```

set up the 20 participant loop (inner loop) to run in parallel


```{r, eval=FALSE, warning=FALSE, include=FALSE}

library(doParallel)
library(foreach)

#######################################
# Parallel processing setup
cores <- detectCores()
cl <- makeCluster(cores - 4)
registerDoParallel(cl)

big_list <- list()

big_list <- foreach(i = 1:1000) %dopar% {
  big_list[i] <- i^2
}

stopCluster(cl)
#######################################


ptm <- proc.time()
set.seed(666)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10 # simulation iterations
nboot <- 2000 # number of permutation samples
srate <- 500 # sampling rate in Hz
ronset <- seq(150, 170, 2) # random onset for each participant

# Priors for Bayesian model
prior <- list(
  cp_1 = "dunif(100, 250)" # Change point expected between 100 and 250 ms
)

# Setting up Bayesian model
model <- list(
  y ~ 1 + sigma(1),
    ~ 0 + x + sigma(1)
)

Nt <- 50 # number of trials
Np <- 20 # number of participants
outvar <- 1 # noise variance

cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

simres.cp <- matrix(NA, nrow = Np, ncol = nsim)
simres.fdr <- matrix(NA, nrow = Np, ncol = nsim)
simres.cs <- matrix(NA, nrow = Np, ncol = nsim)
simres.pelt <- matrix(NA, nrow = Np, ncol = nsim)
simres.ecp <- matrix(NA, nrow = Np, ncol = nsim)
simres.mcp <- matrix(NA, nrow = Np, ncol = nsim)


for (S in 1:nsim) {
  
  for(P in 1:Np){ # participants
    
    ponset <- sample(ronset, 1) # get random onset
    st <- which(Xf==ponset)
    temp2 <- c(rep(0, st-2), erp, rep(0, Nf-st-length(erp)+2))

    for(T in 1:Nt){
      cond2[T,] <- temp2 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
      cond1[T,] <- temp1 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
    }
    
    # t-tests
    ori.t2 <- vector(mode = "numeric", length = Nf)
    for(F in 1:Nf){
      ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
    }
    
    ###############################################
    
    # Fit BinSeg model
    res <- cpt.meanvar(ori.t2, method = "BinSeg", Q=2)
    simres.cp[P,S] <- Xf[res@cpts[1]]
    
    ###############################################
    
    # Fit PELT with a penalty multiplier of 30
    res.pelt <- cpt.meanvar(ori.t2, method = "PELT", penalty = "Manual", pen.value = 30*log(length(ori.t2)))
    simres.pelt[P,S] <- Xf[res.pelt@cpts[1]]
    
    ###############################################
    
    # Fit mcp model
    df <- tibble(x = Xf, y = ori.t2)

    fit <- mcp(model, prior = prior, data = df)

    summary.fit.median <- summary.mcpfit.median(fit)
    simres.mcp[P,S] <- round(summary.fit.median[1,2],0)
    
    ###############################################
    
    # Make permutation table of t values 
    perm.t2 <- permtdist(cond1, cond2, Nt, Nf, nboot = nboot)^2
    perm.th <- apply(perm.t2, 2, quantile, probs = 1-aath)
    
    # FDR -----
    perm.pvals <- vector(mode = "numeric", length = Nf)
    for(F in 1:Nf){
      perm.pvals[F] <- (sum(perm.t2[,F] >= ori.t2[F]) + 1) / (nboot + 1)
    }
    fdr.pvals <- p.adjust(perm.pvals, method = "fdr")
    simres.fdr[P,S] <- Xf[which(fdr.pvals <= aath)[1]]
    
    ###############################################
    
    # cluster-sum statistics -----
    cmap <- cluster.make(perm.pvals <= aath)
    perm.max.sums <- vector(mode = "numeric", length = nboot)
    for(B in 1:nboot){
      # threshold permutation t2 values and form clusters
      perm.cmap <- cluster.make(perm.t2[B,] <= perm.th)  
      perm.max.sums[B] <- max(cluster.sum(values = perm.t2[B,], cmap = perm.cmap))
    }
    # cluster sum threshold
    cs.th <- quantile(perm.max.sums, probs = 1-aath)
    # cluster test
    cs.test <- cluster.test(values = ori.t2, cmap = cmap, cs.th)
    simres.cs[P,S] <- Xf[cs.test][1]
    
    ##############################################
    
    # Fit non-parametric e.cp3o_delta from ecp package
    ori.t2 <- matrix(ori.t2, ncol = 1) # ecp only accepts matrices 
    
    # Fit ecp cp3o_delta model
    result_cp3o_delta <- e.cp3o_delta(Z = ori.t2, K = 8, alpha = 1)
    simres.ecp[P,S] <- get_earliest_cp(result_cp3o_delta$estimates, Xf)
  }
}

save(simres.cs, simres.fdr, simres.cp, simres.pelt, simres.mcp, simres.mcp.mean, simres.ecp,
     file = "./data/main_sim_n50_eeg_group20.RData")
proc.time()-ptm
```


```{r}
ptm <- proc.time()
set.seed(666)
aath <- 0.05 # arbitrary alpha threshold
nsim <- 10 # simulation iterations
nboot <- 2000 # number of permutation samples
srate <- 500 # sampling rate in Hz
ronset <- seq(150, 170, 2) # random onset for each participant

# Priors for Bayesian model
prior <- list(
  cp_1 = "dunif(100, 250)" # Change point expected between 100 and 250 ms
)

# Setting up Bayesian model
model <- list(
  y ~ 1 + sigma(1),
    ~ 0 + x + sigma(1)
)

Nt <- 50 # number of trials
Np <- 20 # number of participants
outvar <- 1 # noise variance

cond1 <- matrix(0, nrow = Nt, ncol = Nf)
cond2 <- matrix(0, nrow = Nt, ncol = Nf)

simres.cp <- matrix(NA, nrow = Np, ncol = nsim)
simres.fdr <- matrix(NA, nrow = Np, ncol = nsim)
simres.cs <- matrix(NA, nrow = Np, ncol = nsim)
simres.pelt <- matrix(NA, nrow = Np, ncol = nsim)
simres.ecp <- matrix(NA, nrow = Np, ncol = nsim)
simres.mcp <- matrix(NA, nrow = Np, ncol = nsim)

results <- foreach(S = 1:nsim, .combine = 'rbind', .multicombine = TRUE, .packages = c("dplyr", "tibble", "Rfast", "changepoint", "mcp", "rjags", "mutoss", "ecp")) %:% 
  foreach(P = 1:Np, .combine = 'c') %dopar% {
    
    ponset <- sample(ronset, 1)  # Get random onset
    st <- which(Xf == ponset)
    temp2 <- c(rep(0, st-2), erp, rep(0, Nf-st-length(erp)+2))

    # Initialize condition matrices
    cond1 <- matrix(0, nrow = Nt, ncol = Nf)
    cond2 <- matrix(0, nrow = Nt, ncol = Nf)
    
    for(T in 1:Nt){
      cond2[T,] <- temp2 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
      cond1[T,] <- temp1 + eeg_noise(frames = Nf, srate = srate, outvar = outvar, meanpower)
    }

    ori.t2 <- vector(mode = "numeric", length = Nf)
    for(F in 1:Nf){
      ori.t2[F] <- t.test(cond1[,F], cond2[,F])$statistic^2
    }

    # Example output for one type of analysis
    res <- cpt.meanvar(ori.t2, method = "BinSeg", Q = 2)
    cp_location <- Xf[res@cpts[1]]  # Capture change point location

    # Return the result for this participant and simulation
    list(cp_location = cp_location)
}

# Stop the cluster
stopCluster(cl)
proc.time() - ptm

# Save the results to a file
save(results, file = "./data/main_sim_n50_eeg_group20.RData")

```

